############################################
# Data Science Training
# Homework Assignment of Course 1 Session 1
############################################

# Problem 1: Basic Statistical Programming -------------------
# consider the following vector of random numbers drawn from a 
# normal distribution with mean 10 and standard deviation 2
x <- rnorm(100, mean = 10, sd = 2)

# (a) plot a histogram of x using hist()

# (b) compute the sum, mean, median, standard deviation, minimum and maximum values and quantiles of this vector

# (c) manually compute the mean using sum() and length()

# (d) check your computation of the mean, median, minimum, maximum, 2nd and 4th quartile against:
summary(x)

# (e) write a function that takes x as an input and returns the same output as summary(x)

# (f) This inserts 10 missing values at random into x.
x[sample.int(100L, 10L)] <- NA
x
?sample.int  # See the help page of this function, make sure you understand the code above

summary(x)  # see the output now

# (g) Modify your function in part (e) to also replicate this output

# (h) Add an argument 'na.rm' to your function, and modify your function so that it can produce both outputs of (e) and (g) depending on na.rm = TRUE or FALSE

# (i) Consider this dataset that comes with R
mtcars
View(mtcars)
# make sure you understand this code. Look up the individual functions i.e. ?t, ?sapply
summ <- t(sapply(mtcars, summary))
summ
# Examine 'summ'. What kind of object is it?, see the structure and class of it

# (j) apply your function to each column of the data in the same way as shown above. Do you get the same result?

# (k) using the matrix() and sample.int() functions, insert missing values into mtcars and repeat.

# (l) Consider the iris dataset printed below. Create a generic version of your function in part (h), 
#     adding a default method that that tabulates non-numeric data and apply it to the columns of iris using lapply(). 
head(iris)
str(iris)
summary(iris)


# Problem 2: Strings and Dates -----------------------------------
# consider the following vector of fiscal years
y <- 1999:2017
fy <- paste(y - 1L, substr(as.character(y), 3L, 4L), sep = "/")

# (a) make sure you understand how these fiscal year strings were generated by looking up the relevant functions, e.g. ?substr

# (b) wrap this code into a function called FY(), that can create sequences of fiscal years from arbitrary starting and ending calendar years 

# (c) now create a function FY_to_Date() that takes a vector of fiscal years and converts it to a vector of Dates corresponding to the last day (30th of June) of each fiscal year

# (d) generate a vector of fiscal years and apply your function to turn them into dates. 

# (e) using substr(), get the month from these generated dates. 

